(function __HLS_WORKER_BUNDLE__(__IN_WORKER__){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Hls = factory());
})(this, (function () { 'use strict';

  function _construct(t, e, r) {
    if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
    var o = [null];
    o.push.apply(o, e);
    var p = new (t.bind.apply(t, o))();
    return r && _setPrototypeOf(p, r.prototype), p;
  }
  function _defineProperties(e, r) {
    for (var t = 0; t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
      writable: false
    }), e;
  }
  function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e[r] = t, e;
  }
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n;
    }, _extends.apply(null, arguments);
  }
  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t);
    }, _getPrototypeOf(t);
  }
  function _inheritsLoose(t, o) {
    t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
  }
  function _isNativeFunction(t) {
    try {
      return -1 !== Function.toString.call(t).indexOf("[native code]");
    } catch (n) {
      return "function" == typeof t;
    }
  }
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    } catch (t) {}
    return (_isNativeReflectConstruct = function () {
      return !!t;
    })();
  }
  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r) {
        return Object.getOwnPropertyDescriptor(e, r).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread2(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t), true).forEach(function (r) {
        _defineProperty(e, r, t[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
      });
    }
    return e;
  }
  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
      return t.__proto__ = e, t;
    }, _setPrototypeOf(t, e);
  }
  function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r);
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _wrapNativeSuper(t) {
    var r = "function" == typeof Map ? new Map() : void 0;
    return _wrapNativeSuper = function (t) {
      if (null === t || !_isNativeFunction(t)) return t;
      if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
      if (void 0 !== r) {
        if (r.has(t)) return r.get(t);
        r.set(t, Wrapper);
      }
      function Wrapper() {
        return _construct(t, arguments, _getPrototypeOf(this).constructor);
      }
      return Wrapper.prototype = Object.create(t.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      }), _setPrototypeOf(Wrapper, t);
    }, _wrapNativeSuper(t);
  }

  /**
   * Generate a random v4 UUID
   *
   * @returns A random v4 UUID
   *
   * @group Utils
   *
   * @beta
   */
  function uuid() {
    try {
      return crypto.randomUUID();
    } catch (error) {
      try {
        var url = URL.createObjectURL(new Blob());
        var _uuid = url.toString();
        URL.revokeObjectURL(url);
        return _uuid.slice(_uuid.lastIndexOf('/') + 1);
      } catch (error) {
        var dt = new Date().getTime();
        var _uuid2 = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
          var r = (dt + Math.random() * 16) % 16 | 0;
          dt = Math.floor(dt / 16);
          return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);
        });
        return _uuid2;
      }
    }
  }

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  var eventemitter3 = {exports: {}};

  var hasRequiredEventemitter3;

  function requireEventemitter3 () {
  	if (hasRequiredEventemitter3) return eventemitter3.exports;
  	hasRequiredEventemitter3 = 1;
  	(function (module) {

  		var has = Object.prototype.hasOwnProperty
  		  , prefix = '~';

  		/**
  		 * Constructor to create a storage for our `EE` objects.
  		 * An `Events` instance is a plain object whose properties are event names.
  		 *
  		 * @constructor
  		 * @private
  		 */
  		function Events() {}

  		//
  		// We try to not inherit from `Object.prototype`. In some engines creating an
  		// instance in this way is faster than calling `Object.create(null)` directly.
  		// If `Object.create(null)` is not supported we prefix the event names with a
  		// character to make sure that the built-in object properties are not
  		// overridden or used as an attack vector.
  		//
  		if (Object.create) {
  		  Events.prototype = Object.create(null);

  		  //
  		  // This hack is needed because the `__proto__` property is still inherited in
  		  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  		  //
  		  if (!new Events().__proto__) prefix = false;
  		}

  		/**
  		 * Representation of a single event listener.
  		 *
  		 * @param {Function} fn The listener function.
  		 * @param {*} context The context to invoke the listener with.
  		 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
  		 * @constructor
  		 * @private
  		 */
  		function EE(fn, context, once) {
  		  this.fn = fn;
  		  this.context = context;
  		  this.once = once || false;
  		}

  		/**
  		 * Add a listener for a given event.
  		 *
  		 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
  		 * @param {(String|Symbol)} event The event name.
  		 * @param {Function} fn The listener function.
  		 * @param {*} context The context to invoke the listener with.
  		 * @param {Boolean} once Specify if the listener is a one-time listener.
  		 * @returns {EventEmitter}
  		 * @private
  		 */
  		function addListener(emitter, event, fn, context, once) {
  		  if (typeof fn !== 'function') {
  		    throw new TypeError('The listener must be a function');
  		  }

  		  var listener = new EE(fn, context || emitter, once)
  		    , evt = prefix ? prefix + event : event;

  		  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  		  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  		  else emitter._events[evt] = [emitter._events[evt], listener];

  		  return emitter;
  		}

  		/**
  		 * Clear event by name.
  		 *
  		 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
  		 * @param {(String|Symbol)} evt The Event name.
  		 * @private
  		 */
  		function clearEvent(emitter, evt) {
  		  if (--emitter._eventsCount === 0) emitter._events = new Events();
  		  else delete emitter._events[evt];
  		}

  		/**
  		 * Minimal `EventEmitter` interface that is molded against the Node.js
  		 * `EventEmitter` interface.
  		 *
  		 * @constructor
  		 * @public
  		 */
  		function EventEmitter() {
  		  this._events = new Events();
  		  this._eventsCount = 0;
  		}

  		/**
  		 * Return an array listing the events for which the emitter has registered
  		 * listeners.
  		 *
  		 * @returns {Array}
  		 * @public
  		 */
  		EventEmitter.prototype.eventNames = function eventNames() {
  		  var names = []
  		    , events
  		    , name;

  		  if (this._eventsCount === 0) return names;

  		  for (name in (events = this._events)) {
  		    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  		  }

  		  if (Object.getOwnPropertySymbols) {
  		    return names.concat(Object.getOwnPropertySymbols(events));
  		  }

  		  return names;
  		};

  		/**
  		 * Return the listeners registered for a given event.
  		 *
  		 * @param {(String|Symbol)} event The event name.
  		 * @returns {Array} The registered listeners.
  		 * @public
  		 */
  		EventEmitter.prototype.listeners = function listeners(event) {
  		  var evt = prefix ? prefix + event : event
  		    , handlers = this._events[evt];

  		  if (!handlers) return [];
  		  if (handlers.fn) return [handlers.fn];

  		  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
  		    ee[i] = handlers[i].fn;
  		  }

  		  return ee;
  		};

  		/**
  		 * Return the number of listeners listening to a given event.
  		 *
  		 * @param {(String|Symbol)} event The event name.
  		 * @returns {Number} The number of listeners.
  		 * @public
  		 */
  		EventEmitter.prototype.listenerCount = function listenerCount(event) {
  		  var evt = prefix ? prefix + event : event
  		    , listeners = this._events[evt];

  		  if (!listeners) return 0;
  		  if (listeners.fn) return 1;
  		  return listeners.length;
  		};

  		/**
  		 * Calls each of the listeners registered for a given event.
  		 *
  		 * @param {(String|Symbol)} event The event name.
  		 * @returns {Boolean} `true` if the event had listeners, else `false`.
  		 * @public
  		 */
  		EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  		  var evt = prefix ? prefix + event : event;

  		  if (!this._events[evt]) return false;

  		  var listeners = this._events[evt]
  		    , len = arguments.length
  		    , args
  		    , i;

  		  if (listeners.fn) {
  		    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

  		    switch (len) {
  		      case 1: return listeners.fn.call(listeners.context), true;
  		      case 2: return listeners.fn.call(listeners.context, a1), true;
  		      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
  		      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
  		      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
  		      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
  		    }

  		    for (i = 1, args = new Array(len -1); i < len; i++) {
  		      args[i - 1] = arguments[i];
  		    }

  		    listeners.fn.apply(listeners.context, args);
  		  } else {
  		    var length = listeners.length
  		      , j;

  		    for (i = 0; i < length; i++) {
  		      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

  		      switch (len) {
  		        case 1: listeners[i].fn.call(listeners[i].context); break;
  		        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
  		        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
  		        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
  		        default:
  		          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
  		            args[j - 1] = arguments[j];
  		          }

  		          listeners[i].fn.apply(listeners[i].context, args);
  		      }
  		    }
  		  }

  		  return true;
  		};

  		/**
  		 * Add a listener for a given event.
  		 *
  		 * @param {(String|Symbol)} event The event name.
  		 * @param {Function} fn The listener function.
  		 * @param {*} [context=this] The context to invoke the listener with.
  		 * @returns {EventEmitter} `this`.
  		 * @public
  		 */
  		EventEmitter.prototype.on = function on(event, fn, context) {
  		  return addListener(this, event, fn, context, false);
  		};

  		/**
  		 * Add a one-time listener for a given event.
  		 *
  		 * @param {(String|Symbol)} event The event name.
  		 * @param {Function} fn The listener function.
  		 * @param {*} [context=this] The context to invoke the listener with.
  		 * @returns {EventEmitter} `this`.
  		 * @public
  		 */
  		EventEmitter.prototype.once = function once(event, fn, context) {
  		  return addListener(this, event, fn, context, true);
  		};

  		/**
  		 * Remove the listeners of a given event.
  		 *
  		 * @param {(String|Symbol)} event The event name.
  		 * @param {Function} fn Only remove the listeners that match this function.
  		 * @param {*} context Only remove the listeners that have this context.
  		 * @param {Boolean} once Only remove one-time listeners.
  		 * @returns {EventEmitter} `this`.
  		 * @public
  		 */
  		EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  		  var evt = prefix ? prefix + event : event;

  		  if (!this._events[evt]) return this;
  		  if (!fn) {
  		    clearEvent(this, evt);
  		    return this;
  		  }

  		  var listeners = this._events[evt];

  		  if (listeners.fn) {
  		    if (
  		      listeners.fn === fn &&
  		      (!once || listeners.once) &&
  		      (!context || listeners.context === context)
  		    ) {
  		      clearEvent(this, evt);
  		    }
  		  } else {
  		    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
  		      if (
  		        listeners[i].fn !== fn ||
  		        (once && !listeners[i].once) ||
  		        (context && listeners[i].context !== context)
  		      ) {
  		        events.push(listeners[i]);
  		      }
  		    }

  		    //
  		    // Reset the array, or remove it completely if we have no more listeners.
  		    //
  		    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
  		    else clearEvent(this, evt);
  		  }

  		  return this;
  		};

  		/**
  		 * Remove all listeners, or those of the specified event.
  		 *
  		 * @param {(String|Symbol)} [event] The event name.
  		 * @returns {EventEmitter} `this`.
  		 * @public
  		 */
  		EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  		  var evt;

  		  if (event) {
  		    evt = prefix ? prefix + event : event;
  		    if (this._events[evt]) clearEvent(this, evt);
  		  } else {
  		    this._events = new Events();
  		    this._eventsCount = 0;
  		  }

  		  return this;
  		};

  		//
  		// Alias methods names because people roll like that.
  		//
  		EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  		EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  		//
  		// Expose the prefix.
  		//
  		EventEmitter.prefixed = prefix;

  		//
  		// Allow `EventEmitter` to be imported as module namespace.
  		//
  		EventEmitter.EventEmitter = EventEmitter;

  		//
  		// Expose the module.
  		//
  		{
  		  module.exports = EventEmitter;
  		} 
  	} (eventemitter3));
  	return eventemitter3.exports;
  }

  var eventemitter3Exports = requireEventemitter3();
  var EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);

  var urlToolkit = {exports: {}};

  var hasRequiredUrlToolkit;

  function requireUrlToolkit () {
  	if (hasRequiredUrlToolkit) return urlToolkit.exports;
  	hasRequiredUrlToolkit = 1;
  	(function (module, exports) {
  		// see https://tools.ietf.org/html/rfc1808

  		(function (root) {
  		  var URL_REGEX =
  		    /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/;
  		  var FIRST_SEGMENT_REGEX = /^(?=([^\/?#]*))\1([^]*)$/;
  		  var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
  		  var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;

  		  var URLToolkit = {
  		    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
  		    // E.g
  		    // With opts.alwaysNormalize = false (default, spec compliant)
  		    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
  		    // With opts.alwaysNormalize = true (not spec compliant)
  		    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
  		    buildAbsoluteURL: function (baseURL, relativeURL, opts) {
  		      opts = opts || {};
  		      // remove any remaining space and CRLF
  		      baseURL = baseURL.trim();
  		      relativeURL = relativeURL.trim();
  		      if (!relativeURL) {
  		        // 2a) If the embedded URL is entirely empty, it inherits the
  		        // entire base URL (i.e., is set equal to the base URL)
  		        // and we are done.
  		        if (!opts.alwaysNormalize) {
  		          return baseURL;
  		        }
  		        var basePartsForNormalise = URLToolkit.parseURL(baseURL);
  		        if (!basePartsForNormalise) {
  		          throw new Error('Error trying to parse base URL.');
  		        }
  		        basePartsForNormalise.path = URLToolkit.normalizePath(
  		          basePartsForNormalise.path
  		        );
  		        return URLToolkit.buildURLFromParts(basePartsForNormalise);
  		      }
  		      var relativeParts = URLToolkit.parseURL(relativeURL);
  		      if (!relativeParts) {
  		        throw new Error('Error trying to parse relative URL.');
  		      }
  		      if (relativeParts.scheme) {
  		        // 2b) If the embedded URL starts with a scheme name, it is
  		        // interpreted as an absolute URL and we are done.
  		        if (!opts.alwaysNormalize) {
  		          return relativeURL;
  		        }
  		        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
  		        return URLToolkit.buildURLFromParts(relativeParts);
  		      }
  		      var baseParts = URLToolkit.parseURL(baseURL);
  		      if (!baseParts) {
  		        throw new Error('Error trying to parse base URL.');
  		      }
  		      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {
  		        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc
  		        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'
  		        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
  		        baseParts.netLoc = pathParts[1];
  		        baseParts.path = pathParts[2];
  		      }
  		      if (baseParts.netLoc && !baseParts.path) {
  		        baseParts.path = '/';
  		      }
  		      var builtParts = {
  		        // 2c) Otherwise, the embedded URL inherits the scheme of
  		        // the base URL.
  		        scheme: baseParts.scheme,
  		        netLoc: relativeParts.netLoc,
  		        path: null,
  		        params: relativeParts.params,
  		        query: relativeParts.query,
  		        fragment: relativeParts.fragment,
  		      };
  		      if (!relativeParts.netLoc) {
  		        // 3) If the embedded URL's <net_loc> is non-empty, we skip to
  		        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>
  		        // (if any) of the base URL.
  		        builtParts.netLoc = baseParts.netLoc;
  		        // 4) If the embedded URL path is preceded by a slash "/", the
  		        // path is not relative and we skip to Step 7.
  		        if (relativeParts.path[0] !== '/') {
  		          if (!relativeParts.path) {
  		            // 5) If the embedded URL path is empty (and not preceded by a
  		            // slash), then the embedded URL inherits the base URL path
  		            builtParts.path = baseParts.path;
  		            // 5a) if the embedded URL's <params> is non-empty, we skip to
  		            // step 7; otherwise, it inherits the <params> of the base
  		            // URL (if any) and
  		            if (!relativeParts.params) {
  		              builtParts.params = baseParts.params;
  		              // 5b) if the embedded URL's <query> is non-empty, we skip to
  		              // step 7; otherwise, it inherits the <query> of the base
  		              // URL (if any) and we skip to step 7.
  		              if (!relativeParts.query) {
  		                builtParts.query = baseParts.query;
  		              }
  		            }
  		          } else {
  		            // 6) The last segment of the base URL's path (anything
  		            // following the rightmost slash "/", or the entire path if no
  		            // slash is present) is removed and the embedded URL's path is
  		            // appended in its place.
  		            var baseURLPath = baseParts.path;
  		            var newPath =
  		              baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) +
  		              relativeParts.path;
  		            builtParts.path = URLToolkit.normalizePath(newPath);
  		          }
  		        }
  		      }
  		      if (builtParts.path === null) {
  		        builtParts.path = opts.alwaysNormalize
  		          ? URLToolkit.normalizePath(relativeParts.path)
  		          : relativeParts.path;
  		      }
  		      return URLToolkit.buildURLFromParts(builtParts);
  		    },
  		    parseURL: function (url) {
  		      var parts = URL_REGEX.exec(url);
  		      if (!parts) {
  		        return null;
  		      }
  		      return {
  		        scheme: parts[1] || '',
  		        netLoc: parts[2] || '',
  		        path: parts[3] || '',
  		        params: parts[4] || '',
  		        query: parts[5] || '',
  		        fragment: parts[6] || '',
  		      };
  		    },
  		    normalizePath: function (path) {
  		      // The following operations are
  		      // then applied, in order, to the new path:
  		      // 6a) All occurrences of "./", where "." is a complete path
  		      // segment, are removed.
  		      // 6b) If the path ends with "." as a complete path segment,
  		      // that "." is removed.
  		      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');
  		      // 6c) All occurrences of "<segment>/../", where <segment> is a
  		      // complete path segment not equal to "..", are removed.
  		      // Removal of these path segments is performed iteratively,
  		      // removing the leftmost matching pattern on each iteration,
  		      // until no matching pattern remains.
  		      // 6d) If the path ends with "<segment>/..", where <segment> is a
  		      // complete path segment not equal to "..", that
  		      // "<segment>/.." is removed.
  		      while (
  		        path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length
  		      ) {}
  		      return path.split('').reverse().join('');
  		    },
  		    buildURLFromParts: function (parts) {
  		      return (
  		        parts.scheme +
  		        parts.netLoc +
  		        parts.path +
  		        parts.params +
  		        parts.query +
  		        parts.fragment
  		      );
  		    },
  		  };

  		  module.exports = URLToolkit;
  		})(); 
  	} (urlToolkit));
  	return urlToolkit.exports;
  }

  var urlToolkitExports = requireUrlToolkit();

  // https://caniuse.com/mdn-javascript_builtins_number_isfinite
  var isFiniteNumber = Number.isFinite || function (value) {
    return typeof value === 'number' && isFinite(value);
  };

  // https://caniuse.com/mdn-javascript_builtins_number_issafeinteger
  var isSafeInteger = Number.isSafeInteger || function (value) {
    return typeof value === 'number' && Math.abs(value) <= MAX_SAFE_INTEGER;
  };
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

  var ErrorTypes = /*#__PURE__*/function (ErrorTypes) {
    // Identifier for a network error (loading error / timeout ...)
    ErrorTypes["NETWORK_ERROR"] = "networkError";
    // Identifier for a media Error (video/parsing/mediasource error)
    ErrorTypes["MEDIA_ERROR"] = "mediaError";
    // EME (encrypted media extensions) errors
    ErrorTypes["KEY_SYSTEM_ERROR"] = "keySystemError";
    // Identifier for a mux Error (demuxing/remuxing)
    ErrorTypes["MUX_ERROR"] = "muxError";
    // Identifier for all other errors
    ErrorTypes["OTHER_ERROR"] = "otherError";
    return ErrorTypes;
  }({});
  var ErrorDetails = /*#__PURE__*/function (ErrorDetails) {
    ErrorDetails["KEY_SYSTEM_NO_KEYS"] = "keySystemNoKeys";
    ErrorDetails["KEY_SYSTEM_NO_ACCESS"] = "keySystemNoAccess";
    ErrorDetails["KEY_SYSTEM_NO_SESSION"] = "keySystemNoSession";
    ErrorDetails["KEY_SYSTEM_NO_CONFIGURED_LICENSE"] = "keySystemNoConfiguredLicense";
    ErrorDetails["KEY_SYSTEM_LICENSE_REQUEST_FAILED"] = "keySystemLicenseRequestFailed";
    ErrorDetails["KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED"] = "keySystemServerCertificateRequestFailed";
    ErrorDetails["KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED"] = "keySystemServerCertificateUpdateFailed";
    ErrorDetails["KEY_SYSTEM_SESSION_UPDATE_FAILED"] = "keySystemSessionUpdateFailed";
    ErrorDetails["KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED"] = "keySystemStatusOutputRestricted";
    ErrorDetails["KEY_SYSTEM_STATUS_INTERNAL_ERROR"] = "keySystemStatusInternalError";
    ErrorDetails["KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR"] = "keySystemDestroyMediaKeysError";
    ErrorDetails["KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR"] = "keySystemDestroyCloseSessionError";
    ErrorDetails["KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR"] = "keySystemDestroyRemoveSessionError";
    // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}
    ErrorDetails["MANIFEST_LOAD_ERROR"] = "manifestLoadError";
    // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
    ErrorDetails["MANIFEST_LOAD_TIMEOUT"] = "manifestLoadTimeOut";
    // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}
    ErrorDetails["MANIFEST_PARSING_ERROR"] = "manifestParsingError";
    // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}
    ErrorDetails["MANIFEST_INCOMPATIBLE_CODECS_ERROR"] = "manifestIncompatibleCodecsError";
    // Identifier for a level which contains no fragments - data: { url: faulty URL, reason: "no fragments found in level", level: index of the bad level }
    ErrorDetails["LEVEL_EMPTY_ERROR"] = "levelEmptyError";
    // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}
    ErrorDetails["LEVEL_LOAD_ERROR"] = "levelLoadError";
    // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
    ErrorDetails["LEVEL_LOAD_TIMEOUT"] = "levelLoadTimeOut";
    // Identifier for a level parse error - data: { url : faulty URL, error: Error, reason: error message }
    ErrorDetails["LEVEL_PARSING_ERROR"] = "levelParsingError";
    // Identifier for a level switch error - data: { level : faulty level Id, event : error description}
    ErrorDetails["LEVEL_SWITCH_ERROR"] = "levelSwitchError";
    // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}
    ErrorDetails["AUDIO_TRACK_LOAD_ERROR"] = "audioTrackLoadError";
    // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
    ErrorDetails["AUDIO_TRACK_LOAD_TIMEOUT"] = "audioTrackLoadTimeOut";
    // Identifier for a subtitle track load error - data: { url : faulty URL, response : { code: error code, text: error text }}
    ErrorDetails["SUBTITLE_LOAD_ERROR"] = "subtitleTrackLoadError";
    // Identifier for a subtitle track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
    ErrorDetails["SUBTITLE_TRACK_LOAD_TIMEOUT"] = "subtitleTrackLoadTimeOut";
    // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}
    ErrorDetails["FRAG_LOAD_ERROR"] = "fragLoadError";
    // Identifier for fragment load timeout error - data: { frag : fragment object}
    ErrorDetails["FRAG_LOAD_TIMEOUT"] = "fragLoadTimeOut";
    // Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }
    ErrorDetails["FRAG_DECRYPT_ERROR"] = "fragDecryptError";
    // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }
    // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release
    ErrorDetails["FRAG_PARSING_ERROR"] = "fragParsingError";
    // Identifier for a fragment or part load skipped because of a GAP tag or attribute
    ErrorDetails["FRAG_GAP"] = "fragGap";
    // Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }
    ErrorDetails["REMUX_ALLOC_ERROR"] = "remuxAllocError";
    // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}
    ErrorDetails["KEY_LOAD_ERROR"] = "keyLoadError";
    // Identifier for decrypt key load timeout error - data: { frag : fragment object}
    ErrorDetails["KEY_LOAD_TIMEOUT"] = "keyLoadTimeOut";
    // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : { error : exception , mimeType : mimeType }
    ErrorDetails["BUFFER_ADD_CODEC_ERROR"] = "bufferAddCodecError";
    // Triggered when source buffer(s) could not be created using level (manifest CODECS attribute), parsed media, or best guess codec(s) - data: { reason : error reason }
    ErrorDetails["BUFFER_INCOMPATIBLE_CODECS_ERROR"] = "bufferIncompatibleCodecsError";
    // Identifier for a buffer append error - data: append error description
    ErrorDetails["BUFFER_APPEND_ERROR"] = "bufferAppendError";
    // Identifier for a buffer appending error event - data: appending error description
    ErrorDetails["BUFFER_APPENDING_ERROR"] = "bufferAppendingError";
    // Identifier for a buffer stalled error event
    ErrorDetails["BUFFER_STALLED_ERROR"] = "bufferStalledError";
    // Identifier for a buffer full event
    ErrorDetails["BUFFER_FULL_ERROR"] = "bufferFullError";
    // Identifier for a buffer seek over hole event
    ErrorDetails["BUFFER_SEEK_OVER_HOLE"] = "bufferSeekOverHole";
    // Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)
    ErrorDetails["BUFFER_NUDGE_ON_STALL"] = "bufferNudgeOnStall";
    // Identifier for a Interstitial Asset List load error - data: { url: faulty URL, response: { code: error code, text: error text } }
    ErrorDetails["ASSET_LIST_LOAD_ERROR"] = "assetListLoadError";
    // Identifier for a Interstitial Asset List load timeout - data: { url: faulty URL, response: { code: error code, text: error text } }
    ErrorDetails["ASSET_LIST_LOAD_TIMEOUT"] = "assetListLoadTimeout";
    // Identifier for a Interstitial Asset List parsing error - data: { url : faulty URL, reason : error reason, response : { code: error code, text: error text }}
    ErrorDetails["ASSET_LIST_PARSING_ERROR"] = "assetListParsingError";
    // Identifier for a Interstitial Asset List parsing error - data: { url : faulty URL, reason : error reason, response : { code: error code, text: error text }}
    ErrorDetails["INTERSTITIAL_ASSET_ITEM_ERROR"] = "interstitialAssetItemError";
    // Identifier for an internal exception happening inside hls.js while handling an event
    ErrorDetails["INTERNAL_EXCEPTION"] = "internalException";
    // Identifier for an internal call to abort a loader
    ErrorDetails["INTERNAL_ABORTED"] = "aborted";
    // Triggered when attachMedia fails
    ErrorDetails["ATTACH_MEDIA_ERROR"] = "attachMediaError";
    // Uncategorized error
    ErrorDetails["UNKNOWN"] = "unknown";
    return ErrorDetails;
  }({});

  var Events = /*#__PURE__*/function (Events) {
    // Fired before MediaSource is attaching to media element
    Events["MEDIA_ATTACHING"] = "hlsMediaAttaching";
    // Fired when MediaSource has been successfully attached to media element
    Events["MEDIA_ATTACHED"] = "hlsMediaAttached";
    // Fired before detaching MediaSource from media element
    Events["MEDIA_DETACHING"] = "hlsMediaDetaching";
    // Fired when MediaSource has been detached from media element
    Events["MEDIA_DETACHED"] = "hlsMediaDetached";
    // Fired when HTMLMediaElement dispatches "ended" event, or stalls at end of VOD program
    Events["MEDIA_ENDED"] = "hlsMediaEnded";
    // Fired after playback stall is resolved with playing, seeked, or ended event following BUFFER_STALLED_ERROR
    Events["STALL_RESOLVED"] = "hlsStallResolved";
    // Fired when the buffer is going to be reset
    Events["BUFFER_RESET"] = "hlsBufferReset";
    // Fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
    Events["BUFFER_CODECS"] = "hlsBufferCodecs";
    // fired when sourcebuffers have been created - data: { tracks : tracks }
    Events["BUFFER_CREATED"] = "hlsBufferCreated";
    // fired when we append a segment to the buffer - data: { segment: segment object }
    Events["BUFFER_APPENDING"] = "hlsBufferAppending";
    // fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}
    Events["BUFFER_APPENDED"] = "hlsBufferAppended";
    // fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }
    Events["BUFFER_EOS"] = "hlsBufferEos";
    // fired when all buffers are full to the end of the program, after calling MediaSource.endOfStream() (unless restricted)
    Events["BUFFERED_TO_END"] = "hlsBufferedToEnd";
    // fired when the media buffer should be flushed - data { startOffset, endOffset }
    Events["BUFFER_FLUSHING"] = "hlsBufferFlushing";
    // fired when the media buffer has been flushed - data: { }
    Events["BUFFER_FLUSHED"] = "hlsBufferFlushed";
    // fired to signal that a manifest loading starts - data: { url : manifestURL}
    Events["MANIFEST_LOADING"] = "hlsManifestLoading";
    // fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks ], url : manifestURL, stats : LoaderStats }
    Events["MANIFEST_LOADED"] = "hlsManifestLoaded";
    // fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}
    Events["MANIFEST_PARSED"] = "hlsManifestParsed";
    // fired when a level switch is requested - data: { level : id of new level }
    Events["LEVEL_SWITCHING"] = "hlsLevelSwitching";
    // fired when a level switch is effective - data: { level : id of new level }
    Events["LEVEL_SWITCHED"] = "hlsLevelSwitched";
    // fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}
    Events["LEVEL_LOADING"] = "hlsLevelLoading";
    // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : LoaderStats }
    Events["LEVEL_LOADED"] = "hlsLevelLoaded";
    // fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }
    Events["LEVEL_UPDATED"] = "hlsLevelUpdated";
    // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
    Events["LEVEL_PTS_UPDATED"] = "hlsLevelPtsUpdated";
    // fired to notify that levels have changed after removing a level - data: { levels : [available quality levels] }
    Events["LEVELS_UPDATED"] = "hlsLevelsUpdated";
    // fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }
    Events["AUDIO_TRACKS_UPDATED"] = "hlsAudioTracksUpdated";
    // fired when an audio track switching is requested - data: { id : audio track id }
    Events["AUDIO_TRACK_SWITCHING"] = "hlsAudioTrackSwitching";
    // fired when an audio track switch actually occurs - data: { id : audio track id }
    Events["AUDIO_TRACK_SWITCHED"] = "hlsAudioTrackSwitched";
    // fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }
    Events["AUDIO_TRACK_LOADING"] = "hlsAudioTrackLoading";
    // fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : LoaderStats }
    Events["AUDIO_TRACK_LOADED"] = "hlsAudioTrackLoaded";
    // fired when an audio tracks's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, id : track id }
    Events["AUDIO_TRACK_UPDATED"] = "hlsAudioTrackUpdated";
    // fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }
    Events["SUBTITLE_TRACKS_UPDATED"] = "hlsSubtitleTracksUpdated";
    // fired to notify that subtitle tracks were cleared as a result of stopping the media
    Events["SUBTITLE_TRACKS_CLEARED"] = "hlsSubtitleTracksCleared";
    // fired when an subtitle track switch occurs - data: { id : subtitle track id }
    Events["SUBTITLE_TRACK_SWITCH"] = "hlsSubtitleTrackSwitch";
    // fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }
    Events["SUBTITLE_TRACK_LOADING"] = "hlsSubtitleTrackLoading";
    // fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : LoaderStats }
    Events["SUBTITLE_TRACK_LOADED"] = "hlsSubtitleTrackLoaded";
    // fired when a subtitle  racks's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, id : track id }
    Events["SUBTITLE_TRACK_UPDATED"] = "hlsSubtitleTrackUpdated";
    // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }
    Events["SUBTITLE_FRAG_PROCESSED"] = "hlsSubtitleFragProcessed";
    // fired when a set of VTTCues to be managed externally has been parsed - data: { type: string, track: string, cues: [ VTTCue ] }
    Events["CUES_PARSED"] = "hlsCuesParsed";
    // fired when a text track to be managed externally is found - data: { tracks: [ { label: string, kind: string, default: boolean } ] }
    Events["NON_NATIVE_TEXT_TRACKS_FOUND"] = "hlsNonNativeTextTracksFound";
    // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, timescale: timescale, frag : fragment object }
    Events["INIT_PTS_FOUND"] = "hlsInitPtsFound";
    // fired when a fragment loading starts - data: { frag : fragment object }
    Events["FRAG_LOADING"] = "hlsFragLoading";
    // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }
    // FRAG_LOAD_PROGRESS = 'hlsFragLoadProgress',
    // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }
    Events["FRAG_LOAD_EMERGENCY_ABORTED"] = "hlsFragLoadEmergencyAborted";
    // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : LoaderStats }
    Events["FRAG_LOADED"] = "hlsFragLoaded";
    // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, payload : fragment payload, stats : { tstart, tdecrypt } }
    Events["FRAG_DECRYPTED"] = "hlsFragDecrypted";
    // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }
    Events["FRAG_PARSING_INIT_SEGMENT"] = "hlsFragParsingInitSegment";
    // fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }
    Events["FRAG_PARSING_USERDATA"] = "hlsFragParsingUserdata";
    // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }
    Events["FRAG_PARSING_METADATA"] = "hlsFragParsingMetadata";
    // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
    // FRAG_PARSING_DATA = 'hlsFragParsingData',
    // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }
    Events["FRAG_PARSED"] = "hlsFragParsed";
    // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : LoaderStats }
    Events["FRAG_BUFFERED"] = "hlsFragBuffered";
    // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
    Events["FRAG_CHANGED"] = "hlsFragChanged";
    // Identifier for a FPS drop event - data: { currentDropped, currentDecoded, totalDroppedFrames }
    Events["FPS_DROP"] = "hlsFpsDrop";
    // triggered when FPS drop triggers auto level capping - data: { level, droppedLevel }
    Events["FPS_DROP_LEVEL_CAPPING"] = "hlsFpsDropLevelCapping";
    // triggered when maxAutoLevel changes - data { autoLevelCapping, levels, maxAutoLevel, minAutoLevel, maxHdcpLevel }
    Events["MAX_AUTO_LEVEL_UPDATED"] = "hlsMaxAutoLevelUpdated";
    // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }
    Events["ERROR"] = "hlsError";
    // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }
    Events["DESTROYING"] = "hlsDestroying";
    // fired when a decrypt key loading starts - data: { frag : fragment object }
    Events["KEY_LOADING"] = "hlsKeyLoading";
    // fired when a decrypt key loading is completed - data: { frag : fragment object, keyInfo : KeyLoaderInfo }
    Events["KEY_LOADED"] = "hlsKeyLoaded";
    // deprecated; please use BACK_BUFFER_REACHED - data : { bufferEnd: number }
    Events["LIVE_BACK_BUFFER_REACHED"] = "hlsLiveBackBufferReached";
    // fired when the back buffer is reached as defined by the backBufferLength config option - data : { bufferEnd: number }
    Events["BACK_BUFFER_REACHED"] = "hlsBackBufferReached";
    // fired after steering manifest has been loaded - data: { steeringManifest: SteeringManifest object, url: steering manifest URL }
    Events["STEERING_MANIFEST_LOADED"] = "hlsSteeringManifestLoaded";
    // fired when asset list has begun loading
    Events["ASSET_LIST_LOADING"] = "hlsAssetListLoading";
    // fired when a valid asset list is loaded
    Events["ASSET_LIST_LOADED"] = "hlsAssetListLoaded";
    // fired when the list of Interstitial Events and Interstitial Schedule is updated
    Events["INTERSTITIALS_UPDATED"] = "hlsInterstitialsUpdated";
    // fired when the buffer reaches an Interstitial Schedule boundary (both Primary segments and Interstitial Assets)
    Events["INTERSTITIALS_BUFFERED_TO_BOUNDARY"] = "hlsInterstitialsBufferedToBoundary";
    // fired when a player instance for an Interstitial Asset has been created
    Events["INTERSTITIAL_ASSET_PLAYER_CREATED"] = "hlsInterstitialAssetPlayerCreated";
    // Interstitial playback started
    Events["INTERSTITIAL_STARTED"] = "hlsInterstitialStarted";
    // InterstitialAsset playback started
    Events["INTERSTITIAL_ASSET_STARTED"] = "hlsInterstitialAssetStarted";
    // InterstitialAsset playback ended
    Events["INTERSTITIAL_ASSET_ENDED"] = "hlsInterstitialAssetEnded";
    // InterstitialAsset playback errored
    Events["INTERSTITIAL_ASSET_ERROR"] = "hlsInterstitialAssetError";
    // Interstitial playback ended
    Events["INTERSTITIAL_ENDED"] = "hlsInterstitialEnded";
    // Interstitial schedule resumed primary playback
    Events["INTERSTITIALS_PRIMARY_RESUMED"] = "hlsInterstitialsPrimaryResumed";
    // Interstitial players dispatch this event when playout limit is reached
    Events["PLAYOUT_LIMIT_REACHED"] = "hlsPlayoutLimitReached";
    // Event DateRange cue "enter" event dispatched
    Events["EVENT_CUE_ENTER"] = "hlsEventCueEnter";
    return Events;
  }({});

  /**
   * Defines each Event type and payload by Event name. Used in {@link hls.js#HlsEventEmitter} to strongly type the event listener API.
   */

  var PlaylistContextType = {
    MANIFEST: "manifest",
    LEVEL: "level",
    AUDIO_TRACK: "audioTrack",
    SUBTITLE_TRACK: "subtitleTrack"
  };
  var PlaylistLevelType = {
    MAIN: "main",
    AUDIO: "audio",
    SUBTITLE: "subtitle"
  };

  /*
   * compute an Exponential Weighted moving average
   * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
   *  - heavily inspired from shaka-player
   */
  var EWMA = /*#__PURE__*/function () {
    //  About half of the estimated value will be from the last |halfLife| samples by weight.
    function EWMA(halfLife, estimate, weight) {
      if (estimate === void 0) {
        estimate = 0;
      }
      if (weight === void 0) {
        weight = 0;
      }
      this.halfLife = void 0;
      this.alpha_ = void 0;
      this.estimate_ = void 0;
      this.totalWeight_ = void 0;
      this.halfLife = halfLife;
      // Larger values of alpha expire historical data more slowly.
      this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
      this.estimate_ = estimate;
      this.totalWeight_ = weight;
    }
    var _proto = EWMA.prototype;
    _proto.sample = function sample(weight, value) {
      var adjAlpha = Math.pow(this.alpha_, weight);
      this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
      this.totalWeight_ += weight;
    };
    _proto.getTotalWeight = function getTotalWeight() {
      return this.totalWeight_;
    };
    _proto.getEstimate = function getEstimate() {
      if (this.alpha_) {
        var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
        if (zeroFactor) {
          return this.estimate_ / zeroFactor;
        }
      }
      return this.estimate_;
    };
    return EWMA;
  }();

  var EwmaBandWidthEstimator = /*#__PURE__*/function () {
    function EwmaBandWidthEstimator(slow, fast, defaultEstimate, defaultTTFB) {
      if (defaultTTFB === void 0) {
        defaultTTFB = 100;
      }
      this.defaultEstimate_ = void 0;
      this.minWeight_ = void 0;
      this.minDelayMs_ = void 0;
      this.slow_ = void 0;
      this.fast_ = void 0;
      this.defaultTTFB_ = void 0;
      this.ttfb_ = void 0;
      this.defaultEstimate_ = defaultEstimate;
      this.minWeight_ = 0.001;
      this.minDelayMs_ = 50;
      this.slow_ = new EWMA(slow);
      this.fast_ = new EWMA(fast);
      this.defaultTTFB_ = defaultTTFB;
      this.ttfb_ = new EWMA(slow);
    }
    var _proto = EwmaBandWidthEstimator.prototype;
    _proto.update = function update(slow, fast) {
      var slow_ = this.slow_,
        fast_ = this.fast_,
        ttfb_ = this.ttfb_;
      if (slow_.halfLife !== slow) {
        this.slow_ = new EWMA(slow, slow_.getEstimate(), slow_.getTotalWeight());
      }
      if (fast_.halfLife !== fast) {
        this.fast_ = new EWMA(fast, fast_.getEstimate(), fast_.getTotalWeight());
      }
      if (ttfb_.halfLife !== slow) {
        this.ttfb_ = new EWMA(slow, ttfb_.getEstimate(), ttfb_.getTotalWeight());
      }
    };
    _proto.sample = function sample(durationMs, numBytes) {
      durationMs = Math.max(durationMs, this.minDelayMs_);
      var numBits = 8 * numBytes;
      // weight is duration in seconds
      var durationS = durationMs / 1000;
      // value is bandwidth in bits/s
      var bandwidthInBps = numBits / durationS;
      this.fast_.sample(durationS, bandwidthInBps);
      this.slow_.sample(durationS, bandwidthInBps);
    };
    _proto.sampleTTFB = function sampleTTFB(ttfb) {
      // weight is frequency curve applied to TTFB in seconds
      // (longer times have less weight with expected input under 1 second)
      var seconds = ttfb / 1000;
      var weight = Math.sqrt(2) * Math.exp(-Math.pow(seconds, 2) / 2);
      this.ttfb_.sample(weight, Math.max(ttfb, 5));
    };
    _proto.canEstimate = function canEstimate() {
      return this.fast_.getTotalWeight() >= this.minWeight_;
    };
    _proto.getEstimate = function getEstimate() {
      if (this.canEstimate()) {
        // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));
        // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));
        // Take the minimum of these two estimates.  This should have the effect of
        // adapting down quickly, but up more slowly.
        return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
      } else {
        return this.defaultEstimate_;
      }
    };
    _proto.getEstimateTTFB = function getEstimateTTFB() {
      if (this.ttfb_.getTotalWeight() >= this.minWeight_) {
        return this.ttfb_.getEstimate();
      } else {
        return this.defaultTTFB_;
      }
    };
    _proto.destroy = function destroy() {};
    return _createClass(EwmaBandWidthEstimator, [{
      key: "defaultEstimate",
      get: function get() {
        return this.defaultEstimate_;
      }
    }]);
  }();

  var Logger = function Logger(label, logger) {
    this.trace = void 0;
    this.debug = void 0;
    this.log = void 0;
    this.warn = void 0;
    this.info = void 0;
    this.error = void 0;
    var lb = "[" + label + "]:";
    this.trace = noop;
    this.debug = logger.debug.bind(null, lb);
    this.log = logger.log.bind(null, lb);
    this.warn = logger.warn.bind(null, lb);
    this.info = logger.info.bind(null, lb);
    this.error = logger.error.bind(null, lb);
  };
  var noop = function noop() {};
  var fakeLogger = {
    trace: noop,
    debug: noop,
    log: noop,
    warn: noop,
    info: noop,
    error: noop
  };
  function createLogger() {
    return _extends({}, fakeLogger);
  }

  // let lastCallTime;
  // function formatMsgWithTimeInfo(type, msg) {
  //   const now = Date.now();
  //   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';
  //   lastCallTime = now;
  //   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';
  //   return msg;
  // }

  function consolePrintFn(type, id) {
    var func = self.console[type];
    return func ? func.bind(self.console, (id ? '[' + id + '] ' : '') + "[" + type + "] >") : noop;
  }
  function getLoggerFn(key, debugConfig, id) {
    return debugConfig[key] ? debugConfig[key].bind(debugConfig) : consolePrintFn(key, id);
  }
  var exportedLogger = createLogger();
  function enableLogs(debugConfig, context, id) {
    // check that console is available
    var newLogger = createLogger();
    if (typeof console === 'object' && debugConfig === true || typeof debugConfig === 'object') {
      var keys = [
      // Remove out from list here to hard-disable a log-level
      // 'trace',
      'debug', 'log', 'info', 'warn', 'error'];
      keys.forEach(function (key) {
        newLogger[key] = getLoggerFn(key, debugConfig, id);
      });
      // Some browsers don't allow to use bind on console object anyway
      // fallback to default if needed
      try {
        newLogger.log("Debug logs enabled for \"" + context + "\" in hls.js version " + "1.6.7");
      } catch (e) {
        /* log fn threw an exception. All logger methods are no-ops. */
        return createLogger();
      }
      // global exported logger uses the same functions as new logger without `id`
      keys.forEach(function (key) {
        exportedLogger[key] = getLoggerFn(key, debugConfig);
      });
    } else {
      // Reset global exported logger
      _extends(exportedLogger, newLogger);
    }
    return newLogger;
  }
  var logger = exportedLogger;

  var empty;
  var hasRequiredEmpty;
  function requireEmpty() {
    if (hasRequiredEmpty) return empty;
    hasRequiredEmpty = 1;
    // This file is inserted as a shim for modules which we do not want to include into the distro.
    // This replacement is done in the "alias" plugin of the rollup config.
    empty = undefined;
    return empty;
  }

  var emptyExports = requireEmpty();
  var Cues = /*@__PURE__*/getDefaultExportFromCjs(emptyExports);

  function getMediaSource(preferManagedMediaSource) {
    if (preferManagedMediaSource === void 0) {
      preferManagedMediaSource = true;
    }
    if (typeof self === 'undefined') return undefined;
    var mms = (preferManagedMediaSource || !self.MediaSource) && self.ManagedMediaSource;
    return mms || self.MediaSource || self.WebKitMediaSource;
  }
  function isManagedMediaSource(source) {
    return typeof self !== 'undefined' && source === self.ManagedMediaSource;
  }
  function isCompatibleTrackChange(currentTracks, requiredTracks) {
    var trackNames = Object.keys(currentTracks);
    var requiredTrackNames = Object.keys(requiredTracks);
    var trackCount = trackNames.length;
    var requiredTrackCount = requiredTrackNames.length;
    return !trackCount || !requiredTrackCount || trackCount === requiredTrackCount && !trackNames.some(function (name) {
      return requiredTrackNames.indexOf(name) === -1;
    });
  }

  // http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197
  // http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt
  /* utf.js - UTF-8 <=> UTF-16 convertion
   *
   * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
   * Version: 1.0
   * LastModified: Dec 25 1999
   * This library is free.  You can redistribute it and/or modify it.
   */
  /**
   * Converts a UTF-8 array to a string.
   *
   * @param array - The UTF-8 array to convert
   *
   * @returns The string
   *
   * @group Utils
   *
   * @beta
   */
  function utf8ArrayToStr(array, exitOnNull) {
    if (exitOnNull === void 0) {
      exitOnNull = false;
    }
    if (typeof TextDecoder !== 'undefined') {
      var decoder = new TextDecoder('utf-8');
      var decoded = decoder.decode(array);
      if (exitOnNull) {
        // grab up to the first null
        var idx = decoded.indexOf('\0');
        return idx !== -1 ? decoded.substring(0, idx) : decoded;
      }
      // remove any null characters
      return decoded.replace(/\0/g, '');
    }
    var len = array.length;
    var c;
    var char2;
    var char3;
    var out = '';
    var i = 0;
    while (i < len) {
      c = array[i++];
      if (c === 0x00 && exitOnNull) {
        return out;
      } else if (c === 0x00 || c === 0x03) {
        // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it
        continue;
      }
      switch (c >> 4) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
          // 0xxxxxxx
          out += String.fromCharCode(c);
          break;
        case 12:
        case 13:
          // 110x xxxx   10xx xxxx
          char2 = array[i++];
          out += String.fromCharCode((c & 0x1f) << 6 | char2 & 0x3f);
          break;
        case 14:
          // 1110 xxxx  10xx xxxx  10xx xxxx
          char2 = array[i++];
          char3 = array[i++];
          out += String.fromCharCode((c & 0x0f) << 12 | (char2 & 0x3f) << 6 | (char3 & 0x3f) << 0);
          break;
      }
    }
    return out;
  }

  /**
   *  hex dump helper class
   */

  var Hex = {
    hexDump: function hexDump(array) {
      var str = '';
      for (var i = 0; i < array.length; i++) {
        var h = array[i].toString(16);
        if (h.length < 2) {
          h = '0' + h;
        }
        str += h;
      }
      return str;
    }
  };
  function hexToArrayBuffer(str) {
    return Uint8Array.from(str.replace(/^0x/, '').replace(/([\da-fA-F]{2}) ?/g, '0x$1 ').replace(/ +$/, '').split(' ')).buffer;
  }

  var LoadStats = function LoadStats() {
    this.aborted = false;
    this.loaded = 0;
    this.retry = 0;
    this.total = 0;
    this.chunkCount = 0;
    this.bwEstimate = 0;
    this.loading = {
      start: 0,
      first: 0,
      end: 0
    };
    this.parsing = {
      start: 0,
      end: 0
    };
    this.buffering = {
      start: 0,
      first: 0,
      end: 0
    };
  };

  var ElementaryStreamTypes = {
    AUDIO: "audio",
    VIDEO: "video",
    AUDIOVIDEO: "audiovideo"
  };
  var BaseSegment = /*#__PURE__*/function () {
    function BaseSegment(base) {
      this._byteRange = null;
      this._url = null;
      this._stats = null;
      this._streams = null;
      // baseurl is the URL to the playlist
      this.base = void 0;
      // relurl is the portion of the URL that comes from inside the playlist.
      this.relurl = void 0;
      if (typeof base === 'string') {
        base = {
          url: base
        };
      }
      this.base = base;
      makeEnumerable(this, 'stats');
    }

    // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array
    var _proto = BaseSegment.prototype;
    _proto.setByteRange = function setByteRange(value, previous) {
      var params = value.split('@', 2);
      var start;
      if (params.length === 1) {
        start = (previous == null ? void 0 : previous.byteRangeEndOffset) || 0;
      } else {
        start = parseInt(params[1]);
      }
      this._byteRange = [start, parseInt(params[0]) + start];
    };
    _proto.clearElementaryStreamInfo = function clearElementaryStreamInfo() {
      var elementaryStreams = this.elementaryStreams;
      elementaryStreams[ElementaryStreamTypes.AUDIO] = null;
      elementaryStreams[ElementaryStreamTypes.VIDEO] = null;
      elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;
    };
    return _createClass(BaseSegment, [{
      key: "baseurl",
      get: function get() {
        return this.base.url;
      }
    }, {
      key: "byteRange",
      get: function get() {
        if (this._byteRange === null) {
          return [];
        }
        return this._byteRange;
      }
    }, {
      key: "byteRangeStartOffset",
      get: function get() {
        return this.byteRange[0];
      }
    }, {
      key: "byteRangeEndOffset",
      get: function get() {
        return this.byteRange[1];
      }
    }, {
      key: "elementaryStreams",
      get: function get() {
        if (this._streams === null) {
          var _this$_streams;
          this._streams = (_this$_streams = {}, _this$_streams[ElementaryStreamTypes.AUDIO] = null, _this$_streams[ElementaryStreamTypes.VIDEO] = null, _this$_streams[ElementaryStreamTypes.AUDIOVIDEO] = null, _this$_streams);
        }
        return this._streams;
      },
      set: function set(value) {
        this._streams = value;
      }
    }, {
      key: "hasStats",
      get: function get() {
        return this._stats !== null;
      }
    }, {
      key: "hasStreams",
      get: function get() {
        return this._streams !== null;
      }
    }, {
      key: "stats",
      get: function get() {
        if (this._stats === null) {
          this._stats = new LoadStats();
        }
        return this._stats;
      },
      set: function set(value) {
        this._stats = value;
      }
    }, {
      key: "url",
      get: function get() {
        if (!this._url && this.baseurl && this.relurl) {
          this._url = urlToolkitExports.buildAbsoluteURL(this.baseurl, this.relurl, {
            alwaysNormalize: true
          });
        }
        return this._url || '';
      },
      set: function set(value) {
        this._url = value;
      }
    }]);
  }();
  function isMediaFragment(frag) {
    return frag.sn !== 'initSegment';
  }

  /**
   * Object representing parsed data from an HLS Segment. Found in {@link hls.js#LevelDetails.fragments}.
   */
  var Fragment = /*#__PURE__*/function (_BaseSegment2) {
    function Fragment(type, base) {
      var _this;
      _this = _BaseSegment2.call(this, base) || this;
      _this._decryptdata = null;
      _this._programDateTime = null;
      _this._ref = null;
      // Approximate bit rate of the fragment expressed in bits per second (bps) as indicated by the last EXT-X-BITRATE (kbps) tag
      _this._bitrate = void 0;
      _this.rawProgramDateTime = null;
      _this.tagList = [];
      // EXTINF has to be present for a m3u8 to be considered valid
      _this.duration = 0;
      // sn notates the sequence number for a segment, and if set to a string can be 'initSegment'
      _this.sn = 0;
      // levelkeys are the EXT-X-KEY tags that apply to this segment for decryption
      // core difference from the private field _decryptdata is the lack of the initialized IV
      // _decryptdata will set the IV for this segment based on the segment number in the fragment
      _this.levelkeys = void 0;
      // A string representing the fragment type
      _this.type = void 0;
      // A reference to the loader. Set while the fragment is loading, and removed afterwards. Used to abort fragment loading
      _this.loader = null;
      // A reference to the key loader. Set while the key is loading, and removed afterwards. Used to abort key loading
      _this.keyLoader = null;
      // The level/track index to which the fragment belongs
      _this.level = -1;
      // The continuity counter of the fragment
      _this.cc = 0;
      // The starting Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.
      _this.startPTS = void 0;
      // The ending Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.
      _this.endPTS = void 0;
      // The starting Decode Time Stamp (DTS) of the fragment. Set after transmux complete.
      _this.startDTS = void 0;
      // The ending Decode Time Stamp (DTS) of the fragment. Set after transmux complete.
      _this.endDTS = void 0;
      // The start time of the fragment, as listed in the manifest. Updated after transmux complete.
      _this.start = 0;
      // The offset time (seconds) of the fragment from the start of the Playlist
      _this.playlistOffset = 0;
      // Set by `updateFragPTSDTS` in level-helper
      _this.deltaPTS = void 0;
      // The maximum starting Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.
      _this.maxStartPTS = void 0;
      // The minimum ending Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.
      _this.minEndPTS = void 0;
      // Init Segment bytes (unset for media segments)
      _this.data = void 0;
      // A flag indicating whether the segment was downloaded in order to test bitrate, and was not buffered
      _this.bitrateTest = false;
      // #EXTINF  segment title
      _this.title = null;
      // The Media Initialization Section for this segment
      _this.initSegment = null;
      // Fragment is the last fragment in the media playlist
      _this.endList = void 0;
      // Fragment is marked by an EXT-X-GAP tag indicating that it does not contain media data and should not be loaded
      _this.gap = void 0;
      // Deprecated
      _this.urlId = 0;
      _this.type = type;
      return _this;
    }
    _inheritsLoose(Fragment, _BaseSegment2);
    var _proto2 = Fragment.prototype;
    _proto2.addStart = function addStart(value) {
      this.setStart(this.start + value);
    };
    _proto2.setStart = function setStart(value) {
      this.start = value;
      if (this._ref) {
        this._ref.start = value;
      }
    };
    _proto2.setDuration = function setDuration(value) {
      this.duration = value;
      if (this._ref) {
        this._ref.duration = value;
      }
    };
    _proto2.setKeyFormat = function setKeyFormat(keyFormat) {
      if (this.levelkeys) {
        var key = this.levelkeys[keyFormat];
        if (key && !this._decryptdata) {
          this._decryptdata = key.getDecryptData(this.sn);
        }
      }
    };
    _proto2.abortRequests = function abortRequests() {
      var _this$loader, _this$keyLoader;
      (_this$loader = this.loader) == null ? void 0 : _this$loader.abort();
      (_this$keyLoader = this.keyLoader) == null ? void 0 : _this$keyLoader.abort();
    };
    _proto2.setElementaryStreamInfo = function setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial) {
      if (partial === void 0) {
        partial = false;
      }
      var elementaryStreams = this.elementaryStreams;
      var info = elementaryStreams[type];
      if (!info) {
        elementaryStreams[type] = {
          startPTS: startPTS,
          endPTS: endPTS,
          startDTS: startDTS,
          endDTS: endDTS,
          partial: partial
        };
        return;
      }
      info.startPTS = Math.min(info.startPTS, startPTS);
      info.endPTS = Math.max(info.endPTS, endPTS);
      info.startDTS = Math.min(info.startDTS, startDTS);
      info.endDTS = Math.max(info.endDTS, endDTS);
    };
    return _createClass(Fragment, [{
      key: "byteLength",
      get: function get() {
        if (this.hasStats) {
          var total = this.stats.total;
          if (total) {
            return total;
          }
        }
        if (this.byteRange) {
          var start = this.byteRange[0];
          var end = this.byteRange[1];
          if (isFiniteNumber(start) && isFiniteNumber(end)) {
            return end - start;
          }
        }
        return null;
      }
    }, {
      key: "bitrate",
      get: function get() {
        if (this.byteLength) {
          return this.byteLength * 8 / this.duration;
        }
        if (this._bitrate) {
          return this._bitrate;
        }
        return null;
      },
      set: function set(value) {
        this._bitrate = value;
      }
    }, {
      key: "decryptdata",
      get: function get() {
        var levelkeys = this.levelkeys;
        if (!levelkeys && !this._decryptdata) {
          return null;
        }
        if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
          var key = this.levelkeys.identity;
          if (key) {
            this._decryptdata = key.getDecryptData(this.sn);
          } else {
            var keyFormats = Object.keys(this.levelkeys);
            if (keyFormats.length === 1) {
              return this._decryptdata = this.levelkeys[keyFormats[0]].getDecryptData(this.sn);
            }
          }
        }
        return this._decryptdata;
      }
    }, {
      key: "end",
      get: function get() {
        return this.start + this.duration;
      }
    }, {
      key: "endProgramDateTime",
      get: function get() {
        if (this.programDateTime === null) {
          return null;
        }
        var duration = !isFiniteNumber(this.duration) ? 0 : this.duration;
        return this.programDateTime + duration * 1000;
      }
    }, {
      key: "encrypted",
      get: function get() {
        var _this$_decryptdata;
        // At the m3u8-parser level we need to add support for manifest signalled keyformats
        // when we want the fragment to start reporting that it is encrypted.
        // Currently, keyFormat will only be set for identity keys
        if ((_this$_decryptdata = this._decryptdata) != null && _this$_decryptdata.encrypted) {
          return true;
        } else if (this.levelkeys) {
          var keyFormats = Object.keys(this.levelkeys);
          var len = keyFormats.length;
          if (len > 1 || len === 1 && this.levelkeys[keyFormats[0]].encrypted) {
            return true;
          }
        }
        return false;
      }
    }, {
      key: "programDateTime",
      get: function get() {
        if (this._programDateTime === null && this.rawProgramDateTime) {
          this.programDateTime = Date.parse(this.rawProgramDateTime);
        }
        return this._programDateTime;
      },
      set: function set(value) {
        if (!isFiniteNumber(value)) {
          this._programDateTime = this.rawProgramDateTime = null;
          return;
        }
        this._programDateTime = value;
      }
    }, {
      key: "ref",
      get: function get() {
        if (!isMediaFragment(this)) {
          return null;
        }
        if (!this._ref) {
          this._ref = {
            base: this.base,
            start: this.start,
            duration: this.duration,
            sn: this.sn,
            programDateTime: this.programDateTime
          };
        }
        return this._ref;
      }
    }]);
  }(BaseSegment);

  /**
   * Object representing parsed data from an HLS Partial Segment. Found in {@link hls.js#LevelDetails.partList}.
   */
  var Part = /*#__PURE__*/function (_BaseSegment3) {
    function Part(partAttrs, frag, base, index, previous) {
      var _this2;
      _this2 = _BaseSegment3.call(this, base) || this;
      _this2.fragOffset = 0;
      _this2.duration = 0;
      _this2.gap = false;
      _this2.independent = false;
      _this2.relurl = void 0;
      _this2.fragment = void 0;
      _this2.index = void 0;
      _this2.duration = partAttrs.decimalFloatingPoint('DURATION');
      _this2.gap = partAttrs.bool('GAP');
      _this2.independent = partAttrs.bool('INDEPENDENT');
      _this2.relurl = partAttrs.enumeratedString('URI');
      _this2.fragment = frag;
      _this2.index = index;
      var byteRange = partAttrs.enumeratedString('BYTERANGE');
      if (byteRange) {
        _this2.setByteRange(byteRange, previous);
      }
      if (previous) {
        _this2.fragOffset = previous.fragOffset + previous.duration;
      }
      return _this2;
    }
    _inheritsLoose(Part, _BaseSegment3);
    return _createClass(Part, [{
      key: "start",
      get: function get() {
        return this.fragment.start + this.fragOffset;
      }
    }, {
      key: "end",
      get: function get() {
        return this.start + this.duration;
      }
    }, {
      key: "loaded",
      get: function get() {
        var elementaryStreams = this.elementaryStreams;
        return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);
      }
    }]);
  }(BaseSegment);
  function getOwnPropertyDescriptorFromPrototypeChain(object, property) {
    var prototype = Object.getPrototypeOf(object);
    if (prototype) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(prototype, property);
      if (propertyDescriptor) {
        return propertyDescriptor;
      }
      return getOwnPropertyDescriptorFromPrototypeChain(prototype, property);
    }
  }
  function makeEnumerable(object, property) {
    var d = getOwnPropertyDescriptorFromPrototypeChain(object, property);
    if (d) {
      d.enumerable = true;
      Object.defineProperty(object, property, d);
    }
  }

  var UINT32_MAX$1 = Math.pow(2, 32) - 1;
  var push = [].push;

  // We are using fixed track IDs for driving the MP4 remuxer
  // instead of following the TS PIDs.
  // There is no reason not to do this and some browsers/SourceBuffer-demuxers
  // may not like if there are TrackID "switches"
  // See https://github.com/video-dev/hls.js/issues/1331
  // Here we are mapping our internal track types to constant MP4 track IDs
  // With MSE currently one can only have one track of each, and we are muxing
  // whatever video/audio rendition in them.
  var RemuxerTrackIdConfig = {
    video: 1,
    audio: 2,
    id3: 3,
    text: 4
  };
  function bin2str(data) {
    return String.fromCharCode.apply(null, data);
  }
  function readUint16(buffer, offset) {
    var val = buffer[offset] << 8 | buffer[offset + 1];
    return val < 0 ? 65536 + val : val;
  }
  function readUint32(buffer, offset) {
    var val = readSint32(buffer, offset);
    return val < 0 ? 4294967296 + val : val;
  }
  function readUint64(buffer, offset) {
    var result = readUint32(buffer, offset);
    result *= Math.pow(2, 32);
    result += readUint32(buffer, offset + 4);
    return result;
  }
  function readSint32(buffer, offset) {
    return buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];
  }

  // Find "moof" box
  function hasMoofData(data) {
    var end = data.byteLength;
    for (var i = 0; i < end;) {
      var size = readUint32(data, i);
      if (size > 8 && data[i + 4] === 0x6d && data[i + 5] === 0x6f && data[i + 6] === 0x6f && data[i + 7] === 0x66) {
        return true;
      }
      i = size > 1 ? i + size : end;
    }
    return false;
  }

  // Find the data for a box specified by its path
  function findBox(data, path) {
    var results = [];
    if (!path.length) {
      // short-circuit the search for empty paths
      return results;
    }
    var end = data.byteLength;
    for (var i = 0; i < end;) {
      var size = readUint32(data, i);
      var type = bin2str(data.subarray(i + 4, i + 8));
      var endbox = size > 1 ? i + size : end;
      if (type === path[0]) {
        if (path.length === 1) {
          // this is the end of the path and we've found the box we were
          // looking for
          results.push(data.subarray(i + 8, endbox));
        } else {
          // recursively search for the next box along the path
          var subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));
          if (subresults.length) {
            push.apply(results, subresults);
          }
        }
      }
      i = endbox;
    }

    // we've finished searching all of data
    return results;
  }
  function parseSegmentIndex(sidx) {
    var references = [];
    var version = sidx[0];

    // set initial offset, we skip the reference ID (not needed)
    var index = 8;
    var timescale = readUint32(sidx, index);
    index += 4;
    var earliestPresentationTime = 0;
    var firstOffset = 0;
    if (version === 0) {
      earliestPresentationTime = readUint32(sidx, index);
      firstOffset = readUint32(sidx, index + 4);
      index += 8;
    } else {
      earliestPresentationTime = readUint64(sidx, index);
      firstOffset = readUint64(sidx, index + 8);
      index += 16;
    }

    // skip reserved
    index += 2;
    var startByte = sidx.length + firstOffset;
    var referencesCount = readUint16(sidx, index);
    index += 2;
    for (var i = 0; i < referencesCount; i++) {
      var referenceIndex = index;
      var referenceInfo = readUint32(sidx, referenceIndex);
      referenceIndex += 4;
      var referenceSize = referenceInfo & 0x7fffffff;
      var referenceType = (referenceInfo & 0x80000000) >>> 31;
      if (referenceType === 1) {
        logger.warn('SIDX has hierarchical references (not supported)');
        return null;
      }
      var subsegmentDuration = readUint32(sidx, referenceIndex);
      referenceIndex += 4;
      references.push({
        referenceSize: referenceSize,
        subsegmentDuration: subsegmentDuration,
        // unscaled
        info: {
          duration: subsegmentDuration / timescale,
          start: startByte,
          end: startByte + referenceSize - 1
        }
      });
      startByte += referenceSize;

      // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits
      // for |sapDelta|.
      referenceIndex += 4;

      // skip to next ref
      index = referenceIndex;
    }
    return {
      earliestPresentationTime: earliestPresentationTime,
      timescale: timescale,
      version: version,
      referencesCount: referencesCount,
      references: references
    };
  }

  /**
   * Parses an MP4 initialization segment and extracts stream type and
   * timescale values for any declared tracks. Timescale values indicate the
   * number of clock ticks per second to assume for time-based values
   * elsewhere in the MP4.
   *
   * To determine the start time of an MP4, you need two pieces of
   * information: the timescale unit and the earliest base media decode
   * time. Multiple timescales can be specified within an MP4 but the
   * base media decode time is always expressed in the timescale from
   * the media header box for the track:
   * ```
   * moov > trak > mdia > mdhd.timescale
   * moov > trak > mdia > hdlr
   * ```
   * @param initSegment the bytes of the init segment
   * @returns a hash of track type to timescale values or null if
   * the init segment is malformed.
   */

  function parseInitSegment(initSegment) {
    var result = [];
    var traks = findBox(initSegment, ['moov', 'trak']);
    for (var i = 0; i < traks.length; i++) {
      var trak = traks[i];
      var tkhd = findBox(trak, ['tkhd'])[0];
      if (tkhd) {
        var version = tkhd[0];
        var trackId = readUint32(tkhd, version === 0 ? 12 : 20);
        var mdhd = findBox(trak, ['mdia', 'mdhd'])[0];
        if (mdhd) {
          version = mdhd[0];
          var timescale = readUint32(mdhd, version === 0 ? 12 : 20);
          var hdlr = findBox(trak, ['mdia', 'hdlr'])[0];
          if (hdlr) {
            var hdlrType = bin2str(hdlr.subarray(8, 12));
            var type = {
              soun: ElementaryStreamTypes.AUDIO,
              vide: ElementaryStreamTypes.VIDEO
            }[hdlrType];
            // Parse codec details
            var stsdBox = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];
            var stsd = parseStsd(stsdBox);
            if (type) {
              // Add 'audio', 'video', and 'audiovideo' track records that will map to SourceBuffers
              result[trackId] = {
                timescale: timescale,
                type: type,
                stsd: stsd
              };
              result[type] = _objectSpread2({
                timescale: timescale,
                id: trackId
              }, stsd);
            } else {
              // Add 'meta' and other track records
              result[trackId] = {
                timescale: timescale,
                type: hdlrType,
                stsd: stsd
              };
            }
          }
        }
      }
    }
    var trex = findBox(initSegment, ['moov', 'mvex', 'trex']);
    trex.forEach(function (trex) {
      var trackId = readUint32(trex, 4);
      var track = result[trackId];
      if (track) {
        track.default = {
          duration: readUint32(trex, 12),
          flags: readUint32(trex, 20)
        };
      }
    });
    return result;
  }
  function parseStsd(stsd) {
    var sampleEntries = stsd.subarray(8);
    var sampleEntriesEnd = sampleEntries.subarray(8 + 78);
    var fourCC = bin2str(sampleEntries.subarray(4, 8));
    var codec = fourCC;
    var supplemental;
    var encrypted = fourCC === 'enca' || fourCC === 'encv';
    if (encrypted) {
      var encBox = findBox(sampleEntries, [fourCC])[0];
      var encBoxChildren = encBox.subarray(fourCC === 'enca' ? 28 : 78);
      var sinfs = findBox(encBoxChildren, ['sinf']);
      sinfs.forEach(function (sinf) {
        var schm = findBox(sinf, ['schm'])[0];
        if (schm) {
          var scheme = bin2str(schm.subarray(4, 8));
          if (scheme === 'cbcs' || scheme === 'cenc') {
            var frma = findBox(sinf, ['frma'])[0];
            if (frma) {
              // for encrypted content codec fourCC will be in frma
              codec = bin2str(frma);
            }
          }
        }
      });
    }
    var codecFourCC = codec;
    switch (codec) {
      case 'avc1':
      case 'avc2':
      case 'avc3':
      case 'avc4':
        {
          // extract profile + compatibility + level out of avcC box
          var avcCBox = findBox(sampleEntriesEnd, ['avcC'])[0];
          if (avcCBox && avcCBox.length > 3) {
            codec += '.' + toHex(avcCBox[1]) + toHex(avcCBox[2]) + toHex(avcCBox[3]);
            supplemental = parseSupplementalDoViCodec(codecFourCC === 'avc1' ? 'dva1' : 'dvav', sampleEntriesEnd);
          }
          break;
        }
      case 'mp4a':
        {
          var codecBox = findBox(sampleEntries, [fourCC])[0];
          var esdsBox = findBox(codecBox.subarray(28), ['esds'])[0];
          if (esdsBox && esdsBox.length > 7) {
            var i = 4;
            // ES Descriptor tag
            if (esdsBox[i++] !== 0x03) {
              break;
            }
            i = skipBERInteger(esdsBox, i);
            i += 2; // skip es_id;
            var flags = esdsBox[i++];
            if (flags & 0x80) {
              i += 2; // skip dependency es_id
            }
            if (flags & 0x40) {
              i += esdsBox[i++]; // skip URL
            }
            // Decoder config descriptor
            if (esdsBox[i++] !== 0x04) {
              break;
            }
            i = skipBERInteger(esdsBox, i);
            var objectType = esdsBox[i++];
            if (objectType === 0x40) {
              codec += '.' + toHex(objectType);
            } else {
              break;
            }
            i += 12;
            // Decoder specific info
            if (esdsBox[i++] !== 0x05) {
              break;
            }
            i = skipBERInteger(esdsBox, i);
            var firstByte = esdsBox[i++];
            var audioObjectType = (firstByte & 0xf8) >> 3;
            if (audioObjectType === 31) {
              audioObjectType += 1 + ((firstByte & 0x7) << 3) + ((esdsBox[i] & 0xe0) >> 5);
            }
            codec += '.' + audioObjectType;
          }
          break;
        }
      case 'hvc1':
      case 'hev1':
        {
          var hvcCBox = findBox(sampleEntriesEnd, ['hvcC'])[0];
          if (hvcCBox && hvcCBox.length > 12) {
            var profileByte = hvcCBox[1];
            var profileSpace = ['', 'A', 'B', 'C'][profileByte >> 6];
            var generalProfileIdc = profileByte & 0x1f;
            var profileCompat = readUint32(hvcCBox, 2);
            var tierFlag = (profileByte & 0x20) >> 5 ? 'H' : 'L';
            var levelIDC = hvcCBox[12];
            var constraintIndicator = hvcCBox.subarray(6, 12);
            codec += '.' + profileSpace + generalProfileIdc;
            codec += '.' + reverse32BitInt(profileCompat).toString(16).toUpperCase();
            codec += '.' + tierFlag + levelIDC;
            var constraintString = '';
            for (var _i = constraintIndicator.length; _i--;) {
              var _byte = constraintIndicator[_i];
              if (_byte || constraintString) {
                var encodedByte = _byte.toString(16).toUpperCase();
                constraintString = '.' + encodedByte + constraintString;
              }
            }
            codec += constraintString;
          }
          supplemental = parseSupplementalDoViCodec(codecFourCC == 'hev1' ? 'dvhe' : 'dvh1', sampleEntriesEnd);
          break;
        }
      case 'dvh1':
      case 'dvhe':
      case 'dvav':
      case 'dva1':
      case 'dav1':
        {
          codec = parseSupplementalDoViCodec(codec, sampleEntriesEnd) || codec;
          break;
        }
      case 'vp09':
        {
          var vpcCBox = findBox(sampleEntriesEnd, ['vpcC'])[0];
          if (vpcCBox && vpcCBox.length > 6) {
            var profile = vpcCBox[4];
            var level = vpcCBox[5];
            var bitDepth = vpcCBox[6] >> 4 & 0x0f;
            codec += '.' + addLeadingZero(profile) + '.' + addLeadingZero(level) + '.' + addLeadingZero(bitDepth);
          }
          break;
        }
      case 'av01':
        {
          var av1CBox = findBox(sampleEntriesEnd, ['av1C'])[0];
          if (av1CBox && av1CBox.length > 2) {
            var _profile = av1CBox[1] >>> 5;
            var _level = av1CBox[1] & 0x1f;
            var _tierFlag = av1CBox[2] >>> 7 ? 'H' : 'M';
            var highBitDepth = (av1CBox[2] & 0x40) >> 6;
            var twelveBit = (av1CBox[2] & 0x20) >> 5;
            var _bitDepth = _profile === 2 && highBitDepth ? twelveBit ? 12 : 10 : highBitDepth ? 10 : 8;
            var monochrome = (av1CBox[2] & 0x10) >> 4;
            var chromaSubsamplingX = (av1CBox[2] & 0x08) >> 3;
            var chromaSubsamplingY = (av1CBox[2] & 0x04) >> 2;
            var chromaSamplePosition = av1CBox[2] & 0x03;
            // TODO: parse color_description_present_flag
            // default it to BT.709/limited range for now
            // more info https://aomediacodec.github.io/av1-isobmff/#av1codecconfigurationbox-syntax
            var colorPrimaries = 1;
            var transferCharacteristics = 1;
            var matrixCoefficients = 1;
            var videoFullRangeFlag = 0;
            codec += '.' + _profile + '.' + addLeadingZero(_level) + _tierFlag + '.' + addLeadingZero(_bitDepth) + '.' + monochrome + '.' + chromaSubsamplingX + chromaSubsamplingY + chromaSamplePosition + '.' + addLeadingZero(colorPrimaries) + '.' + addLeadingZero(transferCharacteristics) + '.' + addLeadingZero(matrixCoefficients) + '.' + videoFullRangeFlag;
            supplemental = parseSupplementalDoViCodec('dav1', sampleEntriesEnd);
          }
          break;
        }
    }
    return {
      codec: codec,
      encrypted: encrypted,
      supplemental: supplemental
    };
  }
  function parseSupplementalDoViCodec(fourCC, sampleEntriesEnd) {
    var dvvCResult = findBox(sampleEntriesEnd, ['dvvC']); // used by DoVi Profile 8 to 10
    var dvXCBox = dvvCResult.length ? dvvCResult[0] : findBox(sampleEntriesEnd, ['dvcC'])[0]; // used by DoVi Profiles up to 7 and 20
    if (dvXCBox) {
      var doViProfile = dvXCBox[2] >> 1 & 0x7f;
      var doViLevel = dvXCBox[2] << 5 & 0x20 | dvXCBox[3] >> 3 & 0x1f;
      return fourCC + '.' + addLeadingZero(doViProfile) + '.' + addLeadingZero(doViLevel);
    }
  }
  function reverse32BitInt(val) {
    var result = 0;
    for (var i = 0; i < 32; i++) {
      result |= (val >> i & 1) << 32 - 1 - i;
    }
    return result >>> 0;
  }
  function skipBERInteger(bytes, i) {
    var limit = i + 5;
    while (bytes[i++] & 0x80 && i < limit) {
      /* do nothing */
    }
    return i;
  }
  function toHex(x) {
    return ('0' + x.toString(16).toUpperCase()).slice(-2);
  }
  function addLeadingZero(num) {
    return (num < 10 ? '0' : '') + num;
  }
  function patchEncyptionData(initSegment, decryptdata) {
    if (!initSegment || !decryptdata) {
      return initSegment;
    }
    var keyId = decryptdata.keyId;
    if (keyId && decryptdata.isCommonEncryption) {
      var traks = findBox(initSegment, ['moov', 'trak']);
      traks.forEach(function (trak) {
        var stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];

        // skip the sample entry count
        var sampleEntries = stsd.subarray(8);
        var encBoxes = findBox(sampleEntries, ['enca']);
        var isAudio = encBoxes.length > 0;
        if (!isAudio) {
          encBoxes = findBox(sampleEntries, ['encv']);
        }
        encBoxes.forEach(function (enc) {
          var encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);
          var sinfBoxes = findBox(encBoxChildren, ['sinf']);
          sinfBoxes.forEach(function (sinf) {
            var tenc = parseSinf(sinf);
            if (tenc) {
              // Look for default key id (keyID offset is always 8 within the tenc box):
              var tencKeyId = tenc.subarray(8, 24);
              if (!tencKeyId.some(function (b) {
                return b !== 0;
              })) {
                logger.log("[eme] Patching keyId in 'enc" + (isAudio ? 'a' : 'v') + ">sinf>>tenc' box: " + Hex.hexDump(tencKeyId) + " -> " + Hex.hexDump(keyId));
                tenc.set(keyId, 8);
              }
            }
          });
        });
      });
    }
    return initSegment;
  }
  function parseSinf(sinf) {
    var schm = findBox(sinf, ['schm'])[0];
    if (schm) {
      var scheme = bin2str(schm.subarray(4, 8));
      if (scheme === 'cbcs' || scheme === 'cenc') {
        return findBox(sinf, ['schi', 'tenc'])[0];
      }
    }
    return null;
  }

  /*
    For Reference:
    aligned(8) class TrackFragmentHeaderBox
             extends FullBox(tfhd, 0, tf_flags){
       unsigned int(32)  track_ID;
       // all the following are optional fields
       unsigned int(64)  base_data_offset;
       unsigned int(32)  sample_description_index;
       unsigned int(32)  default_sample_duration;
       unsigned int(32)  default_sample_size;
       unsigned int(32)  default_sample_flags
    }
   */

  function getSampleData(data, initData, logger) {
    var tracks = {};
    var trafs = findBox(data, ['moof', 'traf']);
    for (var i = 0; i < trafs.length; i++) {
      var traf = trafs[i];
      // There is only one tfhd & trun per traf
      // This is true for CMAF style content, and we should perhaps check the ftyp
      // and only look for a single trun then, but for ISOBMFF we should check
      // for multiple track runs.
      var tfhd = findBox(traf, ['tfhd'])[0];
      // get the track id from the tfhd
      var id = readUint32(tfhd, 4);
      var track = initData[id];
      if (!track) {
        continue;
      }
      var trackTimes = tracks[id] || (tracks[id] = {
        start: NaN,
        duration: 0,
        sampleCount: 0,
        timescale: track.timescale,
        type: track.type
      });
      // get start DTS
      var tfdt = findBox(traf, ['tfdt'])[0];
      if (tfdt) {
        var version = tfdt[0];
        var baseTime = readUint32(tfdt, 4);
        if (version === 1) {
          // If value is too large, assume signed 64-bit. Negative track fragment decode times are invalid, but they exist in the wild.
          // This prevents large values from being used for initPTS, which can cause playlist sync issues.
          // https://github.com/video-dev/hls.js/issues/5303
          if (baseTime === UINT32_MAX$1) {
            logger.warn("[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time");
          } else {
            baseTime *= UINT32_MAX$1 + 1;
            baseTime += readUint32(tfdt, 8);
          }
        }
        if (isFiniteNumber(baseTime) && (!isFiniteNumber(trackTimes.start) || baseTime < trackTimes.start)) {
          trackTimes.start = baseTime;
        }
      }
      var trackDefault = track.default;
      var tfhdFlags = readUint32(tfhd, 0) | (trackDefault == null ? void 0 : trackDefault.flags);
      var defaultSampleDuration = (trackDefault == null ? void 0 : trackDefault.duration) || 0;
      if (tfhdFlags & 0x000008) {
        // 0x000008 indicates the presence of the default_sample_duration field
        if (tfhdFlags & 0x000002) {
          // 0x000002 indicates the presence of the sample_description_index field, which precedes default_sample_duration
          // If present, the default_sample_duration exists at byte offset 12
          defaultSampleDuration = readUint32(tfhd, 12);
        } else {
          // Otherwise, the duration is at byte offset 8
          defaultSampleDuration = readUint32(tfhd, 8);
        }
      }
      var truns = findBox(traf, ['trun']);
      var sampleDTS = trackTimes.start || 0;
      var rawDuration = 0;
      var sampleDuration = defaultSampleDuration;
      for (var j = 0; j < truns.length; j++) {
        var trun = truns[j];
        var sampleCount = readUint32(trun, 4);
        var sampleIndex = trackTimes.sampleCount;
        trackTimes.sampleCount += sampleCount;
        // Get duration from samples
        var dataOffsetPresent = trun[3] & 0x01;
        var firstSampleFlagsPresent = trun[3] & 0x04;
        var sampleDurationPresent = trun[2] & 0x01;
        var sampleSizePresent = trun[2] & 0x02;
        var sampleFlagsPresent = trun[2] & 0x04;
        var sampleCompositionTimeOffsetPresent = trun[2] & 0x08;
        var offset = 8;
        var remaining = sampleCount;
        if (dataOffsetPresent) {
          offset += 4;
        }
        if (firstSampleFlagsPresent && sampleCount) {
          var isNonSyncSample = trun[offset + 1] & 0x01;
          if (!isNonSyncSample && trackTimes.keyFrameIndex === undefined) {
            trackTimes.keyFrameIndex = sampleIndex;
          }
          offset += 4;
          if (sampleDurationPresent) {
            sampleDuration = readUint32(trun, offset);
            offset += 4;
          } else {
            sampleDuration = defaultSampleDuration;
          }
          if (sampleSizePresent) {
            offset += 4;
          }
          if (sampleCompositionTimeOffsetPresent) {
            offset += 4;
          }
          sampleDTS += sampleDuration;
          rawDuration += sampleDuration;
          remaining--;
        }
        while (remaining--) {
          if (sampleDurationPresent) {
            sampleDuration = readUint32(trun, offset);
            offset += 4;
          } else {
            sampleDuration = defaultSampleDuration;
          }
          if (sampleSizePresent) {
            offset += 4;
          }
          if (sampleFlagsPresent) {
            var _isNonSyncSample = trun[offset + 1] & 0x01;
            if (!_isNonSyncSample) {
              if (trackTimes.keyFrameIndex === undefined) {
                trackTimes.keyFrameIndex = trackTimes.sampleCount - (remaining + 1);
                trackTimes.keyFrameStart = sampleDTS;
              }
            }
            offset += 4;
          }
          if (sampleCompositionTimeOffsetPresent) {
            offset += 4;
          }
          sampleDTS += sampleDuration;
          rawDuration += sampleDuration;
        }
        if (!rawDuration && defaultSampleDuration) {
          rawDuration += defaultSampleDuration * sampleCount;
        }
      }
      trackTimes.duration += rawDuration;
    }
    if (!Object.keys(tracks).some(function (trackId) {
      return tracks[trackId].duration;
    })) {
      // If duration samples are not available in the traf use sidx subsegment_duration
      var sidxMinStart = Infinity;
      var sidxMaxEnd = 0;
      var sidxs = findBox(data, ['sidx']);
      for (var _i2 = 0; _i2 < sidxs.length; _i2++) {
        var sidx = parseSegmentIndex(sidxs[_i2]);
        if (sidx != null && sidx.references) {
          sidxMinStart = Math.min(sidxMinStart, sidx.earliestPresentationTime / sidx.timescale);
          var subSegmentDuration = sidx.references.reduce(function (dur, ref) {
            return dur + ref.info.duration || 0;
          }, 0);
          sidxMaxEnd = Math.max(sidxMaxEnd, subSegmentDuration + sidx.earliestPresentationTime / sidx.timescale);
        }
      }
      if (sidxMaxEnd && isFiniteNumber(sidxMaxEnd)) {
        Object.keys(tracks).forEach(function (trackId) {
          if (!tracks[trackId].duration) {
            tracks[trackId].duration = sidxMaxEnd * tracks[trackId].timescale - tracks[trackId].start;
          }
        });
      }
    }
    return tracks;
  }

  // TODO: Check if the last moof+mdat pair is part of the valid range
  function segmentValidRange(data) {
    var segmentedRange = {
      valid: null,
      remainder: null
    };
    var moofs = findBox(data, ['moof']);
    if (moofs.length < 2) {
      segmentedRange.remainder = data;
      return segmentedRange;
    }
    var last = moofs[moofs.length - 1];
    // Offset by 8 bytes; findBox offsets the start by as much
    segmentedRange.valid = data.slice(0, last.byteOffset - 8);
    segmentedRange.remainder = data.slice(last.byteOffset - 8);
    return segmentedRange;
  }
  function appendUint8Array(data1, data2) {
    var temp = new Uint8Array(data1.length + data2.length);
    temp.set(data1);
    temp.set(data2, data1.length);
    return temp;
  }
  function parseSamples(timeOffset, track) {
    var seiSamples = [];
    var videoData = track.samples;
    var timescale = track.timescale;
    var trackId = track.id;
    var isHEVCFlavor = false;
    var moofs = findBox(videoData, ['moof']);
    moofs.map(function (moof) {
      var moofOffset = moof.byteOffset - 8;
      var trafs = findBox(moof, ['traf']);
      trafs.map(function (traf) {
        // get the base media decode time from the tfdt
        var baseTime = findBox(traf, ['tfdt']).map(function (tfdt) {
          var version = tfdt[0];
          var result = readUint32(tfdt, 4);
          if (version === 1) {
            result *= Math.pow(2, 32);
            result += readUint32(tfdt, 8);
          }
          return result / timescale;
        })[0];
        if (baseTime !== undefined) {
          timeOffset = baseTime;
        }
        return findBox(traf, ['tfhd']).map(function (tfhd) {
          var id = readUint32(tfhd, 4);
          var tfhdFlags = readUint32(tfhd, 0) & 0xffffff;
          var baseDataOffsetPresent = (tfhdFlags & 0x000001) !== 0;
          var sampleDescriptionIndexPresent = (tfhdFlags & 0x000002) !== 0;
          var defaultSampleDurationPresent = (tfhdFlags & 0x000008) !== 0;
          var defaultSampleDuration = 0;
          var defaultSampleSizePresent = (tfhdFlags & 0x000010) !== 0;
          var defaultSampleSize = 0;
          var defaultSampleFlagsPresent = (tfhdFlags & 0x000020) !== 0;
          var tfhdOffset = 8;
          if (id === trackId) {
            if (baseDataOffsetPresent) {
              tfhdOffset += 8;
            }
            if (sampleDescriptionIndexPresent) {
              tfhdOffset += 4;
            }
            if (defaultSampleDurationPresent) {
              defaultSampleDuration = readUint32(tfhd, tfhdOffset);
              tfhdOffset += 4;
            }
            if (defaultSampleSizePresent) {
              defaultSampleSize = readUint32(tfhd, tfhdOffset);
              tfhdOffset += 4;
            }
            if (defaultSampleFlagsPresent) {
              tfhdOffset += 4;
            }
            if (track.type === 'video') {
              isHEVCFlavor = isHEVC(track.codec);
            }
            findBox(traf, ['trun']).map(